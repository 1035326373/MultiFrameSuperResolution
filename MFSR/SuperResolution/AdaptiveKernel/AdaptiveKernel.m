% This program implements the algorithm presented in the following paper% Mohammad Moinul Islam, , Vijayan K. Asari, Mohammed Nazrul Islam, and % Mohammad A. Karim, ?Video super-resolution by adaptive kernel regression,? % Lecture Notes in Computer Science, Published by Springer-Verlag Berlin/% Heidelberg ISSN: 0302-9743 (Print) 1611-3349 (Online), Advances in Visual% Computing, Edited by G. Bebis et al. Proceedings of the International % Symposium on Visual Computing -ISVC - 2009: ISBN: 978-3-642-10519-7, % vol. 5876/2009, pp. 799-806, November 2009%% Inputs:% LR - A sequence of low resolution images%% Outputs:% The estimated HR imagefunction [HR, maxIter] = AdaptiveKernel(LR, F)% set input bufferbuffer = LR;% get input dimensions[m,n,s] = size(LR);% what are these for?h= 0.5;hr= 255;% set scaling factorf= F;% set position by scaling factorfp = f-1;% set iterator by scaling factorfi= f^2;% waitbariter= 1;maxIter= m*n;w=waitbar(0, 'Estimating high-resolution image');% loop through y (image height) minus scaling factor as borderfor i= 1:m-(f)    waitbar(iter/maxIter);        % loop through x (image width) minus scaling factor as border    for j= 1:n-(f)                % init arrays for kernel-regression and kernel-regression-frame (s) pixel values        for l= 1:fi            kr(l) = 0;            krf(l)= 0;        end%        kr_11= 0;%        krf_11= 0;%        kr_12= 0;%        krf_12= 0;%        kr_13= 0;%        krf_13= 0;%        %        kr_21= 0;%        krf_21= 0;%        kr_22= 0;%        krf_22= 0;%        kr_23= 0;%        krf_23= 0;%        %        kr_31= 0;%        krf_31= 0;%        kr_32= 0;%        krf_32= 0;%        kr_33= 0;%        krf_33= 0;                % loop through s frames        for k= 1:s                        % create Gaussian kernel            kr_bilat= (1/(f*pi*hr*hr))*exp(-(norm(buffer(i,j,k)-mean(buffer(i,j,:))).^2)/(f*hr*hr));            %             kr_11= kr_11 + (1/(f*pi*h*h))*exp(-(norm((i-i)^2+(j-j)^2).^2)/(f*h*h))*kr_bilat;%             krf_11= krf_11 + buffer(i,j,k)*(1/(f*pi*h*h))*exp(-(norm((i-i)^2+(j-j)^2).^2)/(f*h*h))*kr_bilat;%             kr_12= kr_12 + (1/(f*pi*h*h))*exp(-(norm((i-i)^2+(j+1-j)^2).^2)/(f*h*h))*kr_bilat;%             krf_12= krf_12 + buffer(i,j+1,k)*(1/(f*pi*h*h))*exp(-(norm((i-i)^2+(j+1-j)^2).^2)/(f*h*h))*kr_bilat;%             kr_13= kr_13 + (1/(f*pi*h*h))*exp(-(norm((i-i)^2+(j+2-j)^2).^2)/(f*h*h))*kr_bilat;%             krf_13= krf_13 + buffer(i,j+2,k)*(1/(f*pi*h*h))*exp(-(norm((i-i)^2+(j+2-j)^2).^2)/(f*h*h))*kr_bilat;%             %             kr_21= kr_21 + (1/(f*pi*h*h))*exp(-(norm((i+1-i)^2+(j-j)^2).^2)/(f*h*h))*kr_bilat;%             krf_21= krf_21 + buffer(i+1,j,k)*(1/(f*pi*h*h))*exp(-(norm((i+1-i)^2+(j-j)^2).^2)/(f*h*h))*kr_bilat;%             kr_22= kr_22 + (1/(f*pi*h*h))*exp(-(norm((i+1-i)^2+(j+1-j)^2).^2)/(f*h*h))*kr_bilat;%             krf_22= krf_22 + buffer(i+1,j+1,k)*(1/(f*pi*h*h))*exp(-(norm((i+1-i)^2+(j+1-j)^2).^2)/(f*h*h))*kr_bilat;%             kr_23= kr_23 + (1/(f*pi*h*h))*exp(-(norm((i+1-i)^2+(j+2-j)^2).^2)/(f*h*h))*kr_bilat;%             krf_23= krf_23 + buffer(i+1,j+2,k)*(1/(f*pi*h*h))*exp(-(norm((i+1-i)^2+(j+2-j)^2).^2)/(f*h*h))*kr_bilat;%             %             kr_31= kr_31 + (1/(f*pi*h*h))*exp(-(norm((i+2-i)^2+(j-j)^2).^2)/(f*h*h))*kr_bilat;%             krf_31= krf_31 + buffer(i+2,j,k)*(1/(f*pi*h*h))*exp(-(norm((i+2-i)^2+(j-j)^2).^2)/(f*h*h))*kr_bilat;%             kr_32= kr_32 + (1/(f*pi*h*h))*exp(-(norm((i+2-i)^2+(j+1-j)^2).^2)/(f*h*h))*kr_bilat;%             krf_32= krf_32 + buffer(i+2,j+1,k)*(1/(f*pi*h*h))*exp(-(norm((i+2-i)^2+(j+1-j)^2).^2)/(f*h*h))*kr_bilat;%             kr_33= kr_33 + (1/(f*pi*h*h))*exp(-(norm((i+2-i)^2+(j+2-j)^2).^2)/(f*h*h))*kr_bilat;%             krf_33= krf_33 + buffer(i+2,j+2,k)*(1/(f*pi*h*h))*exp(-(norm((i+2-i)^2+(j+2-j)^2).^2)/(f*h*h))*kr_bilat;                        % init line and index values            line = 0; idx = 0;            for o= 1:fi                % sum kernel-regression and kernel-regression-frame (k) pixel values                kr(o)= kr(o) + (1/(f*pi*h*h))*exp(-(norm((i+line-i)^2+(j+idx-j)^2).^2)/(f*h*h))*kr_bilat;                krf(o)= krf(o) + buffer(i+line,j+idx,k)*(1/(f*pi*h*h))*exp(-(norm((i+line-i)^2+(j+idx-j)^2).^2)/(f*h*h))*kr_bilat;                idx = idx + 1;                % if index is multiple of resolution factor, increment line                if(mod(o, f) == 0)                    line = line + 1;                    idx = 0;                end            end        end                %tmp= [krf_11/kr_11 krf_12/kr_12 krf_13/kr_13;krf_21/kr_21 krf_22/kr_22 krf_23/kr_23;krf_31/kr_31 krf_32/kr_32 krf_33/kr_33];        % init line and index values        line = 1; idx = 1;        for r= 1:fi                        % fill temporary quadratic matrix in size of resolution factor            tmp(line, idx)= krf(r)/kr(r);            idx = idx + 1;                        % if index is multiple of resolution factor, increment line            if(mod(r, f) == 0)                line = line + 1;                idx = 1;            end        end                % write pixel values from temporary matrix to correct position        %ynew(f*i-2:f*i,f*j-2:f*j)= tmp;        ynew(f*i-fp:f*i,f*j-fp:f*j)= tmp;        iter=iter+1;    end    iter=iter+1;end% median filterHR= medfilt2(ynew,[f f]);close(w);