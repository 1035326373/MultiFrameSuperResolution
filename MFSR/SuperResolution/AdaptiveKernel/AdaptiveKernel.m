% This program implements the algorithm presented in the following paper% Mohammad Moinul Islam, , Vijayan K. Asari, Mohammed Nazrul Islam, and % Mohammad A. Karim, ?Video super-resolution by adaptive kernel regression,? % Lecture Notes in Computer Science, Published by Springer-Verlag Berlin/% Heidelberg ISSN: 0302-9743 (Print) 1611-3349 (Online), Advances in Visual% Computing, Edited by G. Bebis et al. Proceedings of the International % Symposium on Visual Computing -ISVC - 2009: ISBN: 978-3-642-10519-7, % vol. 5876/2009, pp. 799-806, November 2009%% Inputs:% LR - A sequence of low resolution images%% Outputs:% The estimated HR imagefunction [HR, maxIter] = AdaptiveKernel(LR)% set input bufferbuffer = LR;% get input dimensions[m,n,s] = size(LR);% what are these for?h= 0.5;hr= 255;% set scaling factorf= 2;% set scaling iteratorff= f^2;% waitbariter= 1;maxIter= m*n;w=waitbar(0, 'Estimating high-resolution image');% loop through y (image height)for i= 1:m-1    waitbar(iter/maxIter);        % loop through x (image width)    for j= 1:n-1                % init arrays for kernel-regression and kernel-regression-frame (s) pixel values        for l= 1:ff            kr(l) = 0;            krf(l)= 0;        end                % loop through s frames        for k= 1:s                        % create Gaussian kernel            kr_bilat= (1/(f*pi*hr*hr))*exp(-(norm(buffer(i,j,k)-mean(buffer(i,j,:))).^2)/(f*hr*hr));                        %kr_11= kr_11 + (1/(f*pi*h*h))*exp(-(norm((i-i)^2+(j-j)^2).^2)/(f*h*h))*kr_bilat;            %krf_11= krf_11 + buffer(i,j,k)*(1/(f*pi*h*h))*exp(-(norm((i-i)^2+(j-j)^2).^2)/(f*h*h))*kr_bilat;            %kr_12= kr_12 + (1/(f*pi*h*h))*exp(-(norm((i-i)^2+(j+1-j)^2).^2)/(f*h*h))*kr_bilat;            %krf_12= krf_12 + buffer(i,j+1,k)*(1/(f*pi*h*h))*exp(-(norm((i-i)^2+(j+1-j)^2).^2)/(f*h*h))*kr_bilat;            %kr_21= kr_21 + (1/(f*pi*h*h))*exp(-(norm((i+1-i)^2+(j-j)^2).^2)/(f*h*h))*kr_bilat;            %krf_21= krf_21 + buffer(i+1,j,k)*(1/(f*pi*h*h))*exp(-(norm((i+1-i)^2+(j-j)^2).^2)/(f*h*h))*kr_bilat;            %kr_22= kr_22 + (1/(f*pi*h*h))*exp(-(norm((i+1-i)^2+(j+1-j)^2).^2)/(f*h*h))*kr_bilat;            %krf_22= krf_22 + buffer(i+1,j+1,k)*(1/(f*pi*h*h))*exp(-(norm((i+1-i)^2+(j+1-j)^2).^2)/(f*h*h))*kr_bilat;                        % loop through scaling f^f            for l= 1:ff                                % reset modifier vars                jm= 0; im= 0; m= 0;                                % if index is multiple of scaling-factor, increase modifier                %if (l > f)                if (mod(l,f) == 0)                    m= nextpow2(l)-1;                end                                % if index is multiple of 2 set modifier for j                if(mod(l,2) == 0)                    jm= m;                end                                % if index is multiple of 3 or 4 set modifier for i                if(l ~= 1 && (mod(l,3) == 0 || mod(l,3) == 1))                    im= m;                end                                % sum kernel-regression and kernel-regression-frame (k) pixel values                kr(l)= kr(l) + (1/(f*pi*h*h))*exp(-(norm((i+im-i)^2+(j+jm-j)^2).^2)/(f*h*h))*kr_bilat;                krf(l)= krf(l) + buffer(i+im,j+jm,k)*(1/(f*pi*h*h))*exp(-(norm((i+im-i)^2+(j+jm-j)^2).^2)/(f*h*h))*kr_bilat;            end        end                %tmp= [krf_11/kr_11 krf_12/kr_12;krf_21/kr_21 krf_22/kr_22];        % init line and index values        line = 1; idx = 1;        for r= 1:ff                        % fill temporary quadratic matrix in size of resolution factor            tmp(line, idx)= krf(r)/kr(r);            idx = idx + 1;                        % if index is multiple of resolution factor, increment line            if(mod(r, f) == 0)                line = line + 1;                idx = 1;            end        end                % write pixel values from temporary matrix to correct position        ynew(f*i-1:f*i,f*j-1:f*j)= tmp;        iter=iter+1;    end    iter=iter+1;end% median filterHR= medfilt2(ynew,[2 2]);close(w);